


Begriffe, zu denen ich eine Erklärung haben muss:
- referential transparency
- tail recursion und @annotation.tailrec(siehe seite 20 im Buch)
- pattern matching
- partial application/currying
- case: Warum case benutzen? case classes kann man dann pattern matchen, bekommen ein companion object, brauchen kein "val" oder "var" mehr in der parameterliste. außerdem bekommen case classes und case objects eine schönere toString methode (und equals + hashcode)
- ich muss EINDEUTIG den unterschied zwischen foldLeft und foldRight erklären können!
	- foldright geht erst die gesamte liste durch bevor überhaupt summiert wird 1+(2+(3+0))
	am ende wird dann gerechnet: 3+0 = 3 -> 3+2 = 5 -> 5+1 = 6
	dadurch wird die ganze liste auf den stack gepusht. d.h. foldright rollt die liste von hinten auf
	- foldleft dagegen benutzt einen accumulator (im fall von + ist das 0) und verarbeitet alle 		elemente nacheinander. also (((0+1) +2) +3). 
	es wird also gerechnet 0+1 =1 -> 1+2 = 3 -> 3+3 = 6 damit wird die liste von links aufgerollt


ALS AUFGABE: 
- Zeug, das im Buch anhand von List also Cons(a,Cons(...)) gezeigt wird, als Trees implementieren.
- außerdem: Mal die 99 haskell problems anschauen



exercise 2.2:
warum sollte das array nicht sorted sein wenn gt für zwei elemente true ausgibt?
die aufgabe ist doch sinnvoller andersrum, also wenn angenommen werden kann, 
dass die anonyme funktion überprüft OB etwas sorted ist. Dafür heißt die Funktion doch isSorted

Insgesamt finde ich bisher das @annotation.tailrec bisschen seltsam?

exercise 2.3:
"only one solution that compiles" -> sinnvoll als übungsaufgabe?


Große Programmieraufgabe: 
Eher was kurzes, kniffliges als großartig irgendein riesenprojekt zu implementieren. (Also nicht irgendwie lückentext ausfüllen)

Vielleicht irgendwas, was klassischerweise überhaupt nicht funktional klappt? Also z.B. irgendwas, bei dem man eigentlich Exceptions werfen muss (null pointer handling oder so) und das aber funktional implementieren mit options usw?

